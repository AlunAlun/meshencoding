<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />

<title>WebGL Mesh Compression</title>
	<link rel="stylesheet" type="text/css" href="css/reset.css" />
	<link rel="stylesheet" type="text/css" href="css/style.css" />

	<script type="text/javascript" src="js/SIMPL3-full.min.js"></script>
	<script type="text/javascript" src="js/SIMPL3.WebMeshComponent.js"></script>
	

</head>
<body>

<div id="content">
	<div id="centerText">
		<h1>Efficient Representation of Meshes<br> for Web-based Rendering</h1>
		<p>Single mesh, 32-bit index buffer:</p>
		<ul>
			
			<li>11-bit/channel precision for vertices</li>
			<li>16-bit total for normals</li>
			<li>11-bit/channel for textures (where necessary)</li>
		</ul>
		<h3>Happy Buddha</h3>
	    <h4>(84MB Wavefront OBJ; 25.2MB Raw Binary Mesh)</h4>
		<p><a href="index.html?file=assets/buddha/buddha-oct.json">Single Mesh</a> 
			2.7MB, 300ms decompression</p>
		<p><a href="index.html?file=assets/buddha/prog/buddhat.prog.json">Progressive</a>
			3.5MB</p>
			<!-- <br> -->
		<h4>Testing:</h4>
		<p><a href="index.html?file=assets/buddha/buddha-quant.json">Normals Quantized to 11bpc</a></p>
		<p><a href="index.html?file=assets/buddha/buddha-fib-4096.json">Fibonacci Normals 4096</a></p>
		<p><a href="index.html?file=assets/buddha/buddha-fib-1024.json">Fibonacci Normals 1024</a></p>
		<p><a href="index.html?file=assets/buddha/buddha-8.json">8 bit position, fibonacci 256</a></p>	
		<p><a href="index.html?file=assets/buddha/buddha-6.json">6 bit position, fibonacci 256</a></p>	
		<p><a href="index.html?file=assets/buddha/buddha-4.json">4 bit position(!), fibonacci 256</a></p>	

		<h3>Campus</h3>
		<h4>(231MB Wavefront OBJ; 65.5MB Raw Binary Mesh)</h4>
		<p><a href="index.html?file=assets/pm01/PM01.json">Single Mesh</a> 9.1MB, 400ms decompression</p>

	    <!-- <p>Results below with three delivery formats, UTF-8, PNG image, and base128 varint binary. UTF-8 is, by definition, limited
	    to 20ish bits precision, and has to have some ugly hacks inserted to overcome the surrogate pairs. PNG
	    doesn't compress quite so well, but allows a true 32-bit index buffer, and is still a bit of an
		ugly hack. The base128 varint is elegant and permits 29-bits of index data, which should more than
		enough for most meshes</p>
		<h3>Stanford Bunny</h3>
	    <h4>(4.9MB Wavefront OBJ; 1.67MB Raw Binary Mesh)</h4>
		<p><a href="index.html?file=assets/bunny/utf/bunny.json">UTF+gzip.</a>
			 227kB. 80ms decompression.</p>
		<p><a href="index.html?file=assets/bunny/png/bunny.json">PNG.</a>
			 276kB. 550ms decompression.</p>
		<p><a href="index.html?file=assets/bunny/b128/bunny.json">Base128.</a>
			224kB. 80ms decompression.</p>
		<h3>Happy Buddha</h3>
	    <h4>(84MB Wavefront OBJ; 25.2MB Raw Binary Mesh)</h4>
		<p><a href="index.html?file=assets/buddha/utf/buddha.json">UTF+gzip.</a> 
			3.0MB. 300ms decompression</p>
		<p><a href="index.html?file=assets/buddha/png/buddha.json">PNG.</a>
			3.6MB. 1000ms decompression</p>
		<p><a href="index.html?file=assets/buddha/b128/buddha.json">Base128.</a>
			2.8MB. 300ms decompression</p>
		<h3>University of Surrey Campus</h3>
	    <h4>(150MB Wavefront OBJ; 40.1MB Raw Binary Mesh)</h4>
		<p><a href="index.html?file=assets/pm01/utf/pm01.json">UTF+gzip.</a> 8.7MB. 500ms decompression</p>
		<p><a href="index.html?file=assets/pm01/png/pm01.json">PNG.</a> 9.4MB. 1250ms decompression</p>
		<p><a href="index.html?file=assets/pm01/b128/pm01.json">Base128</a> 8.4MB. 400ms decompression</p> -->

		<!-- <p id="footer">October 2015</p> -->
	</div>
</div>

<div id="infoBox">

</div>

<script type="text/javascript">
//
// UI for asset loading bar
var AssetLoader = function(filename, parentElement) {
	this.filename = filename;

	this.parentElement = parentElement;

	this.container = document.createElement("div");
	this.container.id = filename;
	this.container.classList.add("assetLoad");

	this.textBox = document.createElement("span");
	this.textBox.innerHTML = filename;

	this.loadingBar = document.createElement("div");
	this.loadingBar.classList.add("assetLoadBar");

	this.container.appendChild(this.textBox);
	this.container.appendChild(this.loadingBar);
	this.parentElement.appendChild(this.container);

	this.update = function(evt, theMesh, baseSize) {
		// this.loadingBar.style.width = parseInt(4*( (evt.loaded/10)/theMesh.meta.size )) + "px";
		var tbs = baseSize || 0;
		var downloadedSoFar = tbs + (evt.loaded /1000);
		this.loadingBar.style.width = parseInt(4*(  (downloadedSoFar*100) /theMesh.meta.size )) + "px";
	}
	this.destroy = function() {
		this.parentElement.removeChild(this.container);
	}
}

/*
 * Simple function for extracting the url query parameters
 */
function getQueryParams(qs) {
	qs = qs.split("+").join(" ");
	var params = {}, tokens,
	    re = /[?&]?([^=]+)=([^&]*)/g;
	while (tokens = re.exec(qs)) {
	    params[decodeURIComponent(tokens[1])]
	        = decodeURIComponent(tokens[2]);
	}
	return params;
}
//callback to set the camera based on AABB
var setCameraFromAABB = function(AABB) {
	var newTarget = [AABB.min[0]+(AABB.range[0]/2),AABB.min[1]+(AABB.range[1]/2),AABB.min[2]+(AABB.range[2]/2)]
	var distToCenter = newTarget[2]-AABB.range[2]*3;
	var newPosition = [Math.sin(Math.PI)*distToCenter,
       					newTarget[1],
        				Math.cos(Math.PI)*distToCenter];
	SIMPL3.setCamera(newPosition, newTarget);
}

var getProgressive = function(filename) {
	var spl = filename.split('.');
	if (spl[spl.length-2] == "prog")
		return true;
	else return false;
}

/*
 * Init 3D stuffs
 */
var query = getQueryParams(document.location.search);

var TIMER = null;

if (query.file) {
	document.getElementById("centerText").style.display = "none";
	var marker = query.file.lastIndexOf('/');
	var FILEPATH = query.file.substring(0, marker+1);
	var FILENAME = query.file.substring(marker+1);

	var fullfile = FILEPATH+FILENAME;

	//init SIMPL3
	SIMPL3.init("content");

	//set light
	SIMPL3.setLight([-1000, 1000, 1000]);

	//add main asset loading bar
	assetLoader = new AssetLoader(FILENAME, document.getElementById("infoBox"))

	var prog = getProgressive(FILENAME);

	var theMesh;

	if (!prog)
		theMesh = new WebMesh("shaders/webmesh-diffuse-texture.sh",	fullfile, 
			{light:true},setCameraFromAABB);
	else
		theMesh = new ProgressiveWebMesh("shaders/webmesh-diffuse-texture.sh",	fullfile,{light:true},setCameraFromAABB);

	theMesh.onLoadProgress = function(evt) {
	    assetLoader.update(evt, theMesh, theMesh.baseSize);
	}
	theMesh.onLoadComplete = function() {
		assetLoader.destroy();
	}

	//create component and add it to the scene
	SIMPL3.objects.push(theMesh);
}






</script>
</body>
</html>


